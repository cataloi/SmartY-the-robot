<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SmartY the Robot</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f0f0f0; 
            font-family: sans-serif;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { margin: 0 0 5px 0; font-size: 1.2rem; color: #333; }
        p { margin: 0; font-size: 0.9rem; color: #666; }
        .key {
            display: inline-block;
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.8rem;
            font-weight: bold;
            margin: 0 2px;
        }
        .touch-hint {
            position: absolute;
            bottom: 20px;
            color: rgba(0,0,0,0.3);
            font-weight: bold;
            pointer-events: none;
            font-size: 1.2rem;
        }
        #left-hint { left: 40px; }
        #right-hint { right: 40px; }
        
        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 100px;
            height: 100px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            display: none; 
            pointer-events: none;
        }
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: rgba(33, 150, 243, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>Meet SmartY!</h1>
        <p><strong>Move:</strong> Arrows / Ctrl to Run / Space to Jump</p>
        <p><strong>Bird:</strong> <span class="key">B</span> to Call, <span class="key">F</span> to Fly Away</p>
        <p><strong>Camera:</strong> Click & Drag to Rotate, Scroll to Zoom</p>
        <p><strong>Mobile:</strong> Left side Move, Right side Jump</p>
    </div>
    
    <div id="left-hint" class="touch-hint">Drag to Move</div>
    <div id="right-hint" class="touch-hint">Tap to Jump</div>
    
    <div id="joystick-zone"><div id="joystick-knob"></div></div>

    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer;
        let smartY, parrot; 
        let zoom = 1.0; 
        
        // Define a base scale for the character
        const BASE_SCALE = 0.7;

        // Camera Orbit Variables
        let isMouseDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let camYaw = 0;     
        let camPitch = 0.5; 

        let audioCtx;
        
        // Extended Rig to hold references for perching
        const rig = {
            leftArm: { upper: null, lower: null },
            rightArm: { upper: null, lower: null },
            leftLeg: { upper: null, lower: null },
            rightLeg: { upper: null, lower: null },
            head: null,
            chest: null
        };

        const moveSpeed = 0.08; 
        
        let animTime = 0; 
        let lastAnimTime = 0; 

        let leftPupil, rightPupil;
        let eyeTargetX = 0;
        let eyeTargetY = 0.05;
        let nextEyeMove = 0;

        let velocityY = 0;
        let isGrounded = true;
        const gravity = 0.015;
        const jumpForce = 0.45;
        let jumpMomentum = new THREE.Vector3(0, 0, 0);

        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Space: false,
            Control: false
        };

        const touchInput = {
            active: false,
            x: 0, 
            y: 0, 
            run: false,
            id: null,
            startX: 0,
            startY: 0
        };
        
        let pinchStartDist = 0;
        let pinchStartZoom = 1.0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe0e0e0);
            scene.fog = new THREE.Fog(0xe0e0e0, 20, 100);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            scene.add(dirLight);

            const groundGeo = new THREE.PlaneGeometry(200, 200);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x999999, depthWrite: false });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(200, 50, 0x000000, 0x808080);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            createSmartY();
            createParrot(); 

            window.addEventListener('resize', onWindowResize);
            
            // Mouse Drag Listeners
            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mouseup', () => {
                isMouseDragging = false;
            });

            window.addEventListener('mousemove', (e) => {
                if (isMouseDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                    camYaw -= deltaX * 0.005; 
                    camPitch += deltaY * 0.005;
                    camPitch = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camPitch));
                }
            });

            window.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY > 0) {
                    zoom = Math.min(2.5, zoom + 0.1);
                } else {
                    zoom = Math.max(0.5, zoom - 0.1);
                }
            }, { passive: false });

            window.addEventListener('keydown', (e) => { 
                initAudio();
                if(e.code === 'Space') e.preventDefault(); 
                if(e.key === 'Control') keys.Control = true;
                if(keys.hasOwnProperty(e.code) || e.code === 'Space') keys[e.code] = true; 
                
                // Zoom
                if (e.key === '+' || e.key === '=') zoom = Math.max(0.5, zoom - 0.1);
                if (e.key === '-' || e.key === '_') zoom = Math.min(2.5, zoom + 0.1);

                // --- Parrot Controls ---
                if (e.code === 'KeyB') {
                    // Call the Bird (Land on shoulder or arm)
                    if (parrot && parrot.userData.state === 0) {
                        parrot.userData.state = 1; // Force landing
                        const parts = ['lShoulder', 'rShoulder', 'lArm', 'rArm'];
                        const target = parts[Math.floor(Math.random() * parts.length)];
                        parrot.userData.targetObj = target;
                        
                        // Setup Arm Pose if needed
                        if (target.includes('Arm')) {
                            parrot.userData.armPose.z = 1.1 + Math.random() * 0.5; 
                            parrot.userData.armPose.x = 0.1 + Math.random() * 0.4;
                        }
                    }
                }
                if (e.code === 'KeyF') {
                    // Fly Away
                    if (parrot && (parrot.userData.state === 1 || parrot.userData.state === 2)) {
                        parrot.userData.state = 0; // Force fly
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 6 + Math.random() * 4;
                        parrot.userData.targetPos.set(
                            smartY.position.x + Math.sin(angle) * radius,
                            smartY.position.y + 3,
                            smartY.position.z + Math.cos(angle) * radius
                        );
                        parrot.userData.nextActionTime = Date.now() + 2000; // Fly for at least 2s
                    }
                }
            });
            window.addEventListener('keyup', (e) => { 
                if(e.key === 'Control') keys.Control = false;
                if(keys.hasOwnProperty(e.code) || e.code === 'Space') keys[e.code] = false; 
            });

            renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', handleTouchEnd, { passive: false });

            animate();
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } else if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            initAudio();

            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const halfWidth = window.innerWidth / 2;

                if (e.touches.length === 2) {
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    pinchStartDist = Math.sqrt(dx*dx + dy*dy);
                    pinchStartZoom = zoom;
                    continue;
                }

                if (t.clientX < halfWidth) {
                    if (!touchInput.active) {
                        touchInput.active = true;
                        touchInput.id = t.identifier;
                        touchInput.startX = t.clientX;
                        touchInput.startY = t.clientY;
                        touchInput.x = 0;
                        touchInput.y = 0;
                        const joy = document.getElementById('joystick-zone');
                        joy.style.display = 'block';
                        joy.style.left = (t.clientX - 50) + 'px';
                        joy.style.top = (t.clientY - 50) + 'px';
                        updateJoystickVisual(0, 0);
                    }
                } else {
                    keys.Space = true;
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 2) {
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const ratio = pinchStartDist / dist;
                zoom = Math.max(0.5, Math.min(2.5, pinchStartZoom * ratio));
            }

            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (touchInput.active && t.identifier === touchInput.id) {
                    const maxDist = 50; 
                    let dx = t.clientX - touchInput.startX;
                    let dy = t.clientY - touchInput.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > maxDist) {
                        const ratio = maxDist / dist;
                        dx *= ratio;
                        dy *= ratio;
                        touchInput.run = true; 
                    } else {
                        touchInput.run = false;
                    }
                    touchInput.x = dx / maxDist;
                    touchInput.y = dy / maxDist;
                    updateJoystickVisual(dx, dy);
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (touchInput.active && t.identifier === touchInput.id) {
                    touchInput.active = false;
                    touchInput.x = 0;
                    touchInput.y = 0;
                    touchInput.run = false;
                    document.getElementById('joystick-zone').style.display = 'none';
                } else {
                    keys.Space = false;
                }
            }
        }

        function updateJoystickVisual(x, y) {
            const knob = document.getElementById('joystick-knob');
            knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
        }

        function playStepSound(isRunning) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            osc.type = 'triangle'; 
            const startFreq = isRunning ? 180 : 120;
            const endFreq = 40;
            osc.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(endFreq, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function createSmartY() {
            smartY = new THREE.Group();
            smartY.scale.set(BASE_SCALE, BASE_SCALE, BASE_SCALE);

            const blueMat = new THREE.MeshStandardMaterial({ color: 0x2196F3, roughness: 0.3 });
            const darkGreyMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            function addEdges(mesh) {
                const edges = new THREE.EdgesGeometry(mesh.geometry);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                mesh.add(line);
            }

            const torso = new THREE.Group();
            torso.position.y = 2.37; 
            smartY.add(torso);

            const pelvisGeo = new THREE.BoxGeometry(1, 0.4, 0.6);
            const pelvis = new THREE.Mesh(pelvisGeo, blueMat);
            pelvis.position.y = -0.57; 
            pelvis.castShadow = true;
            addEdges(pelvis);
            torso.add(pelvis);

            const waistGeo = new THREE.BoxGeometry(0.85, 0.12, 0.45); 
            const waist = new THREE.Mesh(waistGeo, darkGreyMat);
            waist.position.y = -0.31; 
            waist.castShadow = true;
            addEdges(waist);
            torso.add(waist);

            const chestGeo = new THREE.BoxGeometry(1, 1.0, 0.6); 
            const chest = new THREE.Mesh(chestGeo, blueMat);
            chest.position.y = 0.25; 
            chest.castShadow = true;
            addEdges(chest);
            torso.add(chest);
            
            // Store chest reference for shoulder targeting
            rig.chest = chest;

            const headGeo = new THREE.BoxGeometry(1.2, 1, 1); 
            const head = new THREE.Mesh(headGeo, blueMat);
            head.position.y = 1.4; head.castShadow = true; 
            addEdges(head);
            torso.add(head);
            
            // Store head reference
            rig.head = head;

            const eyeGeo = new THREE.PlaneGeometry(0.25, 0.25);
            const leftEye = new THREE.Mesh(eyeGeo, whiteMat); leftEye.position.set(-0.25, 0.15, 0.51); head.add(leftEye);
            leftPupil = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), blackMat); leftPupil.position.z = 0.01; leftPupil.position.y = 0.05; leftEye.add(leftPupil);
            
            const rightEye = new THREE.Mesh(eyeGeo, whiteMat); rightEye.position.set(0.25, 0.15, 0.51); head.add(rightEye);
            rightPupil = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), blackMat); rightPupil.position.z = 0.01; rightPupil.position.y = 0.05; rightEye.add(rightPupil);

            const mouthGroup = new THREE.Group(); mouthGroup.position.set(0, -0.2, 0.51); head.add(mouthGroup);
            const mouthPixelGeo = new THREE.BoxGeometry(0.06, 0.06, 0.02);
            [[-0.16, 0.05], [-0.09, 0], [0, -0.05], [0.09, 0], [0.16, 0.05]].forEach(pos => {
                const m = new THREE.Mesh(mouthPixelGeo, blackMat); m.position.set(pos[0], pos[1], 0); mouthGroup.add(m);
            });

            const antStem = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.3, 0.05), darkGreyMat); antStem.position.y = 0.65; 
            addEdges(antStem);
            head.add(antStem);
            
            const antBulb = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.15), new THREE.MeshBasicMaterial({color: 0xff0000})); antBulb.position.y = 0.2; 
            antStem.add(antBulb);

            function createArticulatedLimb(isArm, rigTarget) {
                const limbAnchor = new THREE.Group();
                const width = isArm ? 0.25 : 0.3;
                const upperLen = isArm ? 0.5 : 0.7;
                const lowerLen = isArm ? 0.5 : 0.7;
                const jointSize = width * 0.8;

                const upper = new THREE.Mesh(new THREE.BoxGeometry(width, upperLen, width), blueMat);
                upper.position.y = -upperLen / 2; upper.castShadow = true; 
                addEdges(upper);
                limbAnchor.add(upper);

                const lowerPivot = new THREE.Group(); lowerPivot.position.y = -upperLen; limbAnchor.add(lowerPivot);
                const joint = new THREE.Mesh(new THREE.BoxGeometry(jointSize, jointSize, jointSize), darkGreyMat); 
                addEdges(joint);
                lowerPivot.add(joint);

                const lower = new THREE.Mesh(new THREE.BoxGeometry(width, lowerLen, width), blueMat);
                lower.position.y = - (lowerLen / 2) - (jointSize / 2); lower.castShadow = true; 
                addEdges(lower);
                lowerPivot.add(lower);

                if (isArm) {
                    const handGroup = new THREE.Group();
                    handGroup.position.y = -lowerLen - jointSize - 0.02;
                    lowerPivot.add(handGroup);

                    const palm = new THREE.Mesh(new THREE.BoxGeometry(width * 0.9, 0.15, width * 0.9), darkGreyMat);
                    palm.castShadow = true;
                    addEdges(palm);
                    handGroup.add(palm);

                    const fingerGeo = new THREE.BoxGeometry(0.04, 0.12, width * 0.9);
                    
                    const finger1 = new THREE.Mesh(fingerGeo, darkGreyMat);
                    finger1.position.set(-0.08, -0.12, 0); 
                    finger1.castShadow = true;
                    addEdges(finger1);
                    handGroup.add(finger1);

                    const finger2 = new THREE.Mesh(fingerGeo, darkGreyMat);
                    finger2.position.set(0.08, -0.12, 0); 
                    finger2.castShadow = true;
                    addEdges(finger2);
                    handGroup.add(finger2);

                } else {
                    const foot = new THREE.Mesh(new THREE.BoxGeometry(width * 1.1, 0.2, width * 2), darkGreyMat);
                    foot.position.y = -lowerLen - jointSize - 0.1; foot.position.z = width * 0.5; 
                    addEdges(foot);
                    lowerPivot.add(foot);
                }
                rigTarget.upper = limbAnchor; rigTarget.lower = lowerPivot;
                return limbAnchor;
            }

            const leftArm = createArticulatedLimb(true, rig.leftArm); leftArm.position.set(-0.7, 0.6, 0); torso.add(leftArm);
            const rightArm = createArticulatedLimb(true, rig.rightArm); rightArm.position.set(0.7, 0.6, 0); torso.add(rightArm);
            const leftLeg = createArticulatedLimb(false, rig.leftLeg); leftLeg.position.set(-0.3, -0.72, 0); torso.add(leftLeg);
            const rightLeg = createArticulatedLimb(false, rig.rightLeg); rightLeg.position.set(0.3, -0.72, 0); torso.add(rightLeg);

            scene.add(smartY);
        }

        function createParrot() {
            parrot = new THREE.Group();

            const greenMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
            const redMat = new THREE.MeshStandardMaterial({ color: 0xF44336 });
            const yellowMat = new THREE.MeshStandardMaterial({ color: 0xFFEB3B });
            const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            // Initialize Parrot Data with Randomized AI
            // State: 0=FLYING, 1=LANDING, 2=PERCHED
            parrot.userData = { 
                lWing: null, 
                rWing: null,
                state: 0,
                targetPos: new THREE.Vector3(),
                targetObj: null, // "lArm", "rArm", "head", "lShoulder", "rShoulder" or null
                nextActionTime: 0,
                landingOffset: new THREE.Vector3(), // For head offset (avoid antenna)
                armPose: { z: 0, x: 0 } // For randomized arm landing angles
            };

            function addEdges(mesh) {
                const edges = new THREE.EdgesGeometry(mesh.geometry);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                mesh.add(line);
            }

            const body = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.2, 0.25), greenMat);
            addEdges(body); body.castShadow = true; parrot.add(body);

            // [FIXED] Head facing +Z (Forward)
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.12, 0.12), greenMat);
            head.position.set(0, 0.15, 0.1); 
            addEdges(head); head.castShadow = true; parrot.add(head);

            const beak = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.08, 4), yellowMat);
            beak.rotation.x = -Math.PI / 2; beak.rotation.y = Math.PI / 4; 
            beak.position.set(0, 0, 0.08); 
            head.add(beak);

            const eyeGeo = new THREE.PlaneGeometry(0.03, 0.03);
            const leftEye = new THREE.Mesh(eyeGeo, blackMat); leftEye.position.set(-0.061, 0.02, 0.02); leftEye.rotation.y = -Math.PI / 2; head.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, blackMat); rightEye.position.set(0.061, 0.02, 0.02); rightEye.rotation.y = Math.PI / 2; head.add(rightEye);

            const wingGeo = new THREE.BoxGeometry(0.25, 0.02, 0.15);
            
            const lWingGroup = new THREE.Group(); lWingGroup.position.set(-0.08, 0.05, 0); parrot.add(lWingGroup);
            const lWing = new THREE.Mesh(wingGeo, redMat); lWing.position.x = -0.125; addEdges(lWing); lWing.castShadow = true; lWingGroup.add(lWing);

            const rWingGroup = new THREE.Group(); rWingGroup.position.set(0.08, 0.05, 0); parrot.add(rWingGroup);
            const rWing = new THREE.Mesh(wingGeo, redMat); rWing.position.x = 0.125; addEdges(rWing); rWing.castShadow = true; rWingGroup.add(rWing);

            const tail = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.02, 0.2), redMat);
            tail.position.set(0, -0.05, -0.2); 
            addEdges(tail); tail.castShadow = true; parrot.add(tail);

            parrot.userData.lWing = lWingGroup;
            parrot.userData.rWing = rWingGroup;

            parrot.position.set(2, 3, 2);
            scene.add(parrot);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            let holdingParrot = null; 

            // --- Parrot AI Animation ---
            if (parrot && smartY) {
                const now = Date.now();
                const pData = parrot.userData;
                const pTime = now * 0.002;

                if (pData.state === 0) {
                    // --- FLYING STATE ---
                    if (now > pData.nextActionTime) {
                        const rand = Math.random();
                        
                        if (rand < 0.4) {
                            // 40% Chance to LAND
                            pData.state = 1; 
                            
                            const parts = ['head', 'lShoulder', 'rShoulder', 'lArm', 'rArm'];
                            pData.targetObj = parts[Math.floor(Math.random() * parts.length)];
                            
                            if (pData.targetObj === 'head') {
                                const side = Math.random() > 0.5 ? 1 : -1;
                                pData.landingOffset.set(side * 0.35 * BASE_SCALE, 0.55 * BASE_SCALE, 0);
                            } else if (pData.targetObj.includes('Arm')) {
                                pData.armPose.z = 1.1 + Math.random() * 0.5; 
                                pData.armPose.x = 0.1 + Math.random() * 0.4;
                            }

                        } else {
                            const isExploring = Math.random() < 0.3;
                            const radius = isExploring ? 8 + Math.random() * 7 : 3 + Math.random() * 2;
                            const angle = Math.random() * Math.PI * 2;
                            const height = 1.5 + Math.random() * 3.5;
                            
                            pData.targetPos.set(
                                smartY.position.x + Math.sin(angle) * radius,
                                smartY.position.y + height,
                                smartY.position.z + Math.cos(angle) * radius
                            );
                            
                            pData.nextActionTime = now + 3000 + Math.random() * 4000;
                        }
                    }

                    const dist = parrot.position.distanceTo(pData.targetPos);
                    const speed = 0.03 + (dist > 5 ? 0.05 : 0.0);
                    parrot.position.lerp(pData.targetPos, speed);
                    
                    const lookPos = pData.targetPos.clone();
                    lookPos.y = parrot.position.y; 
                    parrot.lookAt(lookPos);

                    // Flying: Wings Spread & Flap
                    const flapSpeed = 15;
                    const unfoldSpeed = 0.1;
                    // Reset Y sweep to 0 (Spread)
                    pData.lWing.rotation.y = THREE.MathUtils.lerp(pData.lWing.rotation.y, 0, unfoldSpeed);
                    pData.rWing.rotation.y = THREE.MathUtils.lerp(pData.rWing.rotation.y, 0, unfoldSpeed);
                    
                    pData.lWing.rotation.z = Math.sin(pTime * flapSpeed) * 0.6;
                    pData.rWing.rotation.z = -Math.sin(pTime * flapSpeed) * 0.6;

                } else if (pData.state === 1) {
                    // --- LANDING STATE ---
                    let targetWorldPos = new THREE.Vector3();
                    
                    if (pData.targetObj === 'lArm') holdingParrot = 'left';
                    if (pData.targetObj === 'rArm') holdingParrot = 'right';

                    if (pData.targetObj === 'head') {
                        rig.head.getWorldPosition(targetWorldPos);
                        targetWorldPos.add(pData.landingOffset); 
                    } else if (pData.targetObj === 'lShoulder') {
                        rig.chest.getWorldPosition(targetWorldPos);
                        const offset = new THREE.Vector3(-0.6 * BASE_SCALE, 0.4 * BASE_SCALE, 0).applyQuaternion(rig.chest.getWorldQuaternion(new THREE.Quaternion()));
                        targetWorldPos.add(offset);
                    } else if (pData.targetObj === 'rShoulder') {
                        rig.chest.getWorldPosition(targetWorldPos);
                        const offset = new THREE.Vector3(0.6 * BASE_SCALE, 0.4 * BASE_SCALE, 0).applyQuaternion(rig.chest.getWorldQuaternion(new THREE.Quaternion()));
                        targetWorldPos.add(offset);
                    } else if (pData.targetObj === 'lArm') {
                        rig.leftArm.lower.getWorldPosition(targetWorldPos);
                        targetWorldPos.y += 0.2; 
                    } else if (pData.targetObj === 'rArm') {
                        rig.rightArm.lower.getWorldPosition(targetWorldPos);
                        targetWorldPos.y += 0.2;
                    }

                    parrot.position.lerp(targetWorldPos, 0.08);
                    parrot.lookAt(targetWorldPos);

                    if (parrot.position.distanceTo(targetWorldPos) < 0.2) {
                        pData.state = 2; // Perched
                        // Random duration 2-5 seconds
                        pData.nextActionTime = now + 2000 + Math.random() * 3000; 
                    }

                    // Fast Flap
                    pData.lWing.rotation.z = Math.sin(pTime * 25) * 0.5;
                    pData.rWing.rotation.z = -Math.sin(pTime * 25) * 0.5;

                } else if (pData.state === 2) {
                    // --- PERCHED STATE ---
                    let anchorPos = new THREE.Vector3();

                    if (pData.targetObj === 'lArm') holdingParrot = 'left';
                    if (pData.targetObj === 'rArm') holdingParrot = 'right';

                    if (pData.targetObj === 'head') {
                        rig.head.getWorldPosition(anchorPos);
                        anchorPos.add(pData.landingOffset); 
                    } else if (pData.targetObj === 'lShoulder') {
                        rig.chest.getWorldPosition(anchorPos);
                        const offset = new THREE.Vector3(-0.6 * BASE_SCALE, 0.4 * BASE_SCALE, 0).applyQuaternion(rig.chest.getWorldQuaternion(new THREE.Quaternion()));
                        anchorPos.add(offset);
                    } else if (pData.targetObj === 'rShoulder') {
                        rig.chest.getWorldPosition(anchorPos);
                        const offset = new THREE.Vector3(0.6 * BASE_SCALE, 0.4 * BASE_SCALE, 0).applyQuaternion(rig.chest.getWorldQuaternion(new THREE.Quaternion()));
                        anchorPos.add(offset);
                    } else if (pData.targetObj === 'lArm') {
                        rig.leftArm.lower.getWorldPosition(anchorPos);
                        anchorPos.y += 0.2; 
                    } else if (pData.targetObj === 'rArm') {
                        rig.rightArm.lower.getWorldPosition(anchorPos);
                        anchorPos.y += 0.2;
                    }

                    parrot.position.copy(anchorPos);
                    parrot.rotation.set(0, smartY.rotation.y, 0); 

                    // WING RETRACTION LOGIC
                    const foldSpeed = 0.1;
                    pData.lWing.rotation.z = THREE.MathUtils.lerp(pData.lWing.rotation.z, 0, foldSpeed);
                    pData.rWing.rotation.z = THREE.MathUtils.lerp(pData.rWing.rotation.z, 0, foldSpeed);
                    
                    pData.lWing.rotation.y = THREE.MathUtils.lerp(pData.lWing.rotation.y, -1.4, foldSpeed);
                    pData.rWing.rotation.y = THREE.MathUtils.lerp(pData.rWing.rotation.y, 1.4, foldSpeed);

                    if (now > pData.nextActionTime) {
                        pData.state = 0; // Take off
                        pData.targetPos.set(parrot.position.x, parrot.position.y + 2, parrot.position.z); 
                        pData.nextActionTime = now + 1000;
                    }
                }
            }

            // --- Eye Animation ---
            if (Date.now() > nextEyeMove) {
                if (Math.random() > 0.3) {
                    eyeTargetX = (Math.random() - 0.5) * 0.14; 
                    eyeTargetY = (Math.random() - 0.5) * 0.14;
                } else { eyeTargetX = 0; eyeTargetY = 0.05; }
                nextEyeMove = Date.now() + 1500 + Math.random() * 2500;
            }
            if (leftPupil && rightPupil) {
                const lerpSpeed = 0.1;
                leftPupil.position.x += (eyeTargetX - leftPupil.position.x) * lerpSpeed;
                leftPupil.position.y += (eyeTargetY - leftPupil.position.y) * lerpSpeed;
                rightPupil.position.x += (eyeTargetX - rightPupil.position.x) * lerpSpeed;
                rightPupil.position.y += (eyeTargetY - rightPupil.position.y) * lerpSpeed;
            }

            let moved = false;
            const moveVec = new THREE.Vector3();
            
            let inputX = 0;
            let inputZ = 0;
            let isRunning = false;

            if (keys.ArrowUp) inputZ -= 1;
            if (keys.ArrowDown) inputZ += 1;
            if (keys.ArrowLeft) inputX -= 1;
            if (keys.ArrowRight) inputX += 1;
            if (keys.Control) isRunning = true;

            if (touchInput.active) {
                inputX += touchInput.x;
                inputZ += touchInput.y;
                if (touchInput.run) isRunning = true;
            }

            const currentSpeed = isRunning ? moveSpeed * 2.2 : moveSpeed;

            if (isGrounded && (Math.abs(inputX) > 0.1 || Math.abs(inputZ) > 0.1)) {
                moved = true;
                moveVec.z = inputZ * currentSpeed;
                moveVec.x = inputX * currentSpeed;
            }

            if (moved && isGrounded) {
                smartY.position.x += moveVec.x;
                smartY.position.z += moveVec.z;
                
                const targetRotation = Math.atan2(moveVec.x, moveVec.z);
                let rotDiff = targetRotation - smartY.rotation.y;
                while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                smartY.rotation.y += rotDiff * 0.8; 
            }

            if (keys.Space && isGrounded) {
                velocityY = jumpForce;
                isGrounded = false;
                smartY.scale.set(BASE_SCALE * 1.1, BASE_SCALE * 0.85, BASE_SCALE * 1.1);
                const forwardImpulse = currentSpeed * 0.8; 
                jumpMomentum.x = Math.sin(smartY.rotation.y) * forwardImpulse;
                jumpMomentum.z = Math.cos(smartY.rotation.y) * forwardImpulse;
            }

            if (velocityY > 0 && !keys.Space) velocityY -= gravity * 2.5;
            else velocityY -= gravity;

            smartY.position.y += velocityY;
            if (!isGrounded) {
                smartY.position.x += jumpMomentum.x;
                smartY.position.z += jumpMomentum.z;
            }

            if (smartY.position.y <= 0) {
                smartY.position.y = 0;
                if (!isGrounded) {
                    smartY.scale.set(BASE_SCALE * 1.1, BASE_SCALE * 0.85, BASE_SCALE * 1.1); 
                    jumpMomentum.set(0, 0, 0);
                }
                velocityY = 0;
                isGrounded = true;
                smartY.scale.lerp(new THREE.Vector3(BASE_SCALE, BASE_SCALE, BASE_SCALE), 0.15);
            } else {
                smartY.scale.lerp(new THREE.Vector3(BASE_SCALE * 0.9, BASE_SCALE * 1.1, BASE_SCALE * 0.9), 0.1);
            }

            // --- ANATOMIC ANIMATION SYSTEM ---
            if (moved) {
                animTime += isRunning ? 0.6 : 0.24; 
            } else {
                animTime += 0.05; 
            }
            
            const torso = smartY.children[0];

            if (torso) {
                if (moved && isGrounded) {
                    const leanAmount = isRunning ? 0.35 : 0.15;
                    torso.rotation.x = THREE.MathUtils.lerp(torso.rotation.x, leanAmount, 0.1); 
                } else {
                    torso.rotation.x = THREE.MathUtils.lerp(torso.rotation.x, 0, 0.1); 
                }
            }

            // Animation targets
            let lArmUpperX = 0, lArmLowerX = -0.1, lArmUpperZ = 0;
            let rArmUpperX = 0, rArmLowerX = -0.1, rArmUpperZ = 0;
            let lLegUpperX = 0, lLegLowerX = 0;
            let rLegUpperX = 0, rLegLowerX = 0;

            if (!isGrounded) {
                // JUMPING
                const targetHip = velocityY > 0 ? -1.2 : 0.0;
                const targetKnee = velocityY > 0 ? 1.5 : 0.2;
                lLegUpperX = targetHip; rLegUpperX = targetHip;
                lLegLowerX = targetKnee; rLegLowerX = targetKnee;
                lArmUpperX = -2.5; rArmUpperX = -2.5;
                lArmLowerX = 0; rArmLowerX = 0;
            } else if (moved) {
                // WALKING
                const walkAmp = isRunning ? 1.0 : 0.8; 
                const forwardBias = isRunning ? -0.1 : -0.25;
                lLegUpperX = -Math.sin(animTime) * walkAmp + forwardBias;
                rLegUpperX = -Math.sin(animTime + Math.PI) * walkAmp + forwardBias;
                lLegLowerX = Math.max(0, Math.cos(animTime)) * (isRunning ? 1.8 : 1.2);
                rLegLowerX = Math.max(0, Math.cos(animTime + Math.PI)) * (isRunning ? 1.8 : 1.2);
                lArmUpperX = -lLegUpperX;
                rArmUpperX = -rLegUpperX;
                lArmLowerX = -0.5 - Math.sin(animTime) * 0.2;
                rArmLowerX = -0.5 - Math.sin(animTime + Math.PI) * 0.2;

                if (Math.floor(animTime / Math.PI) > Math.floor(lastAnimTime / Math.PI)) {
                    playStepSound(isRunning);
                }
            } else {
                // IDLE
                lArmLowerX = -0.1; rArmLowerX = -0.1;
            }

            // --- ARM RAISE OVERRIDE FOR PARROT ---
            if (holdingParrot === 'left') {
                lArmUpperZ = -parrot.userData.armPose.z; 
                lArmUpperX = -parrot.userData.armPose.x; 
                lArmLowerX = -0.2; 
            } else if (holdingParrot === 'right') {
                rArmUpperZ = parrot.userData.armPose.z; 
                rArmUpperX = -parrot.userData.armPose.x; 
                rArmLowerX = -0.2; 
            }

            // Apply Rotations Smoothly
            const lerpSpeed = 0.15;
            rig.leftLeg.upper.rotation.x = THREE.MathUtils.lerp(rig.leftLeg.upper.rotation.x, lLegUpperX, lerpSpeed);
            rig.rightLeg.upper.rotation.x = THREE.MathUtils.lerp(rig.rightLeg.upper.rotation.x, rLegUpperX, lerpSpeed);
            rig.leftLeg.lower.rotation.x = THREE.MathUtils.lerp(rig.leftLeg.lower.rotation.x, lLegLowerX, lerpSpeed);
            rig.rightLeg.lower.rotation.x = THREE.MathUtils.lerp(rig.rightLeg.lower.rotation.x, rLegLowerX, lerpSpeed);

            rig.leftArm.upper.rotation.x = THREE.MathUtils.lerp(rig.leftArm.upper.rotation.x, lArmUpperX, lerpSpeed);
            rig.rightArm.upper.rotation.x = THREE.MathUtils.lerp(rig.rightArm.upper.rotation.x, rArmUpperX, lerpSpeed);
            rig.leftArm.upper.rotation.z = THREE.MathUtils.lerp(rig.leftArm.upper.rotation.z, lArmUpperZ, lerpSpeed);
            rig.rightArm.upper.rotation.z = THREE.MathUtils.lerp(rig.rightArm.upper.rotation.z, rArmUpperZ, lerpSpeed);
            
            rig.leftArm.lower.rotation.x = THREE.MathUtils.lerp(rig.leftArm.lower.rotation.x, lArmLowerX, lerpSpeed);
            rig.rightArm.lower.rotation.x = THREE.MathUtils.lerp(rig.rightArm.lower.rotation.x, rArmLowerX, lerpSpeed);

            lastAnimTime = animTime;

            // Camera Orbit Logic
            const radius = 8 * zoom;
            const offsetY = radius * Math.sin(camPitch);
            const hRadius = radius * Math.cos(camPitch);
            const offsetX = hRadius * Math.sin(camYaw);
            const offsetZ = hRadius * Math.cos(camYaw);

            const targetCamPos = new THREE.Vector3(
                smartY.position.x + offsetX,
                smartY.position.y + offsetY,
                smartY.position.z + offsetZ
            );
            
            const lookTarget = new THREE.Vector3(smartY.position.x, smartY.position.y + 1.2, smartY.position.z);

            camera.position.lerp(targetCamPos, 0.1);
            camera.lookAt(lookTarget);

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
