<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SmartY the Robot</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f0f0f0; 
            font-family: sans-serif;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { margin: 0 0 5px 0; font-size: 1.2rem; color: #333; }
        p { margin: 0; font-size: 0.9rem; color: #666; }
        .key {
            display: inline-block;
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.8rem;
            font-weight: bold;
            margin: 0 2px;
        }
        .touch-hint {
            position: absolute;
            bottom: 20px;
            color: rgba(0,0,0,0.3);
            font-weight: bold;
            pointer-events: none;
            font-size: 1.2rem;
        }
        #left-hint { left: 40px; }
        #right-hint { right: 40px; }
        
        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 100px;
            height: 100px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            display: none; 
            pointer-events: none;
        }
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: rgba(33, 150, 243, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>Meet SmartY!</h1>
        <p><strong>Move:</strong> Arrows / Ctrl to Run / Space to Jump</p>
        <p><strong>Bird:</strong> <span class="key">B</span> to Call, <span class="key">F</span> to Fly Away</p>
        <p><strong>Camera:</strong> Click & Drag to Rotate, Scroll to Zoom</p>
        <p><strong>Mobile:</strong> Left side Move, Right side Jump</p>
    </div>
    
    <div id="left-hint" class="touch-hint">Drag to Move</div>
    <div id="right-hint" class="touch-hint">Tap to Jump</div>
    
    <div id="joystick-zone"><div id="joystick-knob"></div></div>

    <!-- Import Map for module resolution -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
                "three/examples/": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/"
            }
        }
    </script>

    <!-- Use Module type to import RoundedBoxGeometry -->
    <script type="module">
        import * as THREE from 'three';
        import { RoundedBoxGeometry } from 'three/examples/jsm/geometries/RoundedBoxGeometry.js';

        let scene, camera, renderer;
        let smartY, parrot; 
        let zoom = 1.0; 
        
        // Define a base scale for the character
        const BASE_SCALE = 0.7;
        const CORNER_RADIUS = 0.08; 

        // Environment Data for Collisions
        const cityMap = {
            buildings: [],
            sidewalks: []
        };

        // Camera Orbit Variables
        let isMouseDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let camYaw = 0;     
        let camPitch = 0.5; 

        let audioCtx;
        
        // Extended Rig
        const rig = {
            leftArm: { upper: null, lower: null },
            rightArm: { upper: null, lower: null },
            leftLeg: { upper: null, lower: null },
            rightLeg: { upper: null, lower: null },
            head: null,
            chest: null
        };

        const moveSpeed = 0.08; 
        
        let animTime = 0; 
        let lastAnimTime = 0; 

        let leftPupil, rightPupil;
        let eyeTargetX = 0;
        let eyeTargetY = 0.05;
        let nextEyeMove = 0;

        let velocityY = 0;
        let isGrounded = true;
        const gravity = 0.015;
        const jumpForce = 0.45;
        let jumpMomentum = new THREE.Vector3(0, 0, 0);

        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Space: false,
            Control: false
        };

        const touchInput = {
            active: false,
            x: 0, 
            y: 0, 
            run: false,
            id: null,
            startX: 0,
            startY: 0
        };
        
        let pinchStartDist = 0;
        let pinchStartZoom = 1.0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x88ccff); // Sky color
            scene.fog = new THREE.Fog(0x88ccff, 20, 150);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.top = 100;
            dirLight.shadow.camera.bottom = -100;
            dirLight.shadow.camera.left = -100;
            dirLight.shadow.camera.right = 100;
            scene.add(dirLight);

            // Ground - Asphalt
            const groundGeo = new THREE.PlaneGeometry(400, 400);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 }); 
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            createSmartY();
            createParrot(); 
            createCity(); 

            window.addEventListener('resize', onWindowResize);
            
            // Mouse Drag Listeners
            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mouseup', () => {
                isMouseDragging = false;
            });

            window.addEventListener('mousemove', (e) => {
                if (isMouseDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                    camYaw -= deltaX * 0.005; 
                    camPitch += deltaY * 0.005;
                    camPitch = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camPitch));
                }
            });

            window.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY > 0) {
                    zoom = Math.min(2.5, zoom + 0.1);
                } else {
                    zoom = Math.max(0.5, zoom - 0.1);
                }
            }, { passive: false });

            window.addEventListener('keydown', (e) => { 
                initAudio();
                if(e.code === 'Space') e.preventDefault(); 
                if(e.key === 'Control') keys.Control = true;
                if(keys.hasOwnProperty(e.code) || e.code === 'Space') keys[e.code] = true; 
                
                if (e.key === '+' || e.key === '=') zoom = Math.max(0.5, zoom - 0.1);
                if (e.key === '-' || e.key === '_') zoom = Math.min(2.5, zoom + 0.1);

                // --- Parrot Controls ---
                if (e.code === 'KeyB') {
                    if (parrot && parrot.userData.state === 0) {
                        parrot.userData.state = 1; 
                        const parts = ['lShoulder', 'rShoulder', 'lArm', 'rArm'];
                        const target = parts[Math.floor(Math.random() * parts.length)];
                        parrot.userData.targetObj = target;
                        if (target.includes('Arm')) {
                            parrot.userData.armPose.z = 1.1 + Math.random() * 0.5; 
                            parrot.userData.armPose.x = 0.1 + Math.random() * 0.4;
                        }
                    }
                }
                if (e.code === 'KeyF') {
                    if (parrot && (parrot.userData.state === 1 || parrot.userData.state === 2)) {
                        parrot.userData.state = 0; 
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 6 + Math.random() * 4;
                        parrot.userData.targetPos.set(
                            smartY.position.x + Math.sin(angle) * radius,
                            smartY.position.y + 6, // Fly high
                            smartY.position.z + Math.cos(angle) * radius
                        );
                        parrot.userData.nextActionTime = Date.now() + 2000; 
                    }
                }
            });
            window.addEventListener('keyup', (e) => { 
                if(e.key === 'Control') keys.Control = false;
                if(keys.hasOwnProperty(e.code) || e.code === 'Space') keys[e.code] = false; 
            });

            renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', handleTouchEnd, { passive: false });

            animate();
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } else if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // --- PHYSICS & COLLISION HELPERS ---

        function getGroundHeight(x, z) {
            let h = 0.02; // Road level
            for (let sw of cityMap.sidewalks) {
                if (x >= sw.minX && x <= sw.maxX && z >= sw.minZ && z <= sw.maxZ) {
                    h = Math.max(h, sw.height);
                }
            }
            return h;
        }

        function checkBuildingCollision(x, z) {
            const buffer = 0.6; 
            for (let b of cityMap.buildings) {
                if (x >= b.minX - buffer && x <= b.maxX + buffer &&
                    z >= b.minZ - buffer && z <= b.maxZ + buffer) {
                    return true;
                }
            }
            return false;
        }

        // --- Touch Handlers ---
        function handleTouchStart(e) {
            e.preventDefault();
            initAudio();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (e.touches.length === 2) {
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    pinchStartDist = Math.sqrt(dx*dx + dy*dy);
                    pinchStartZoom = zoom;
                    continue;
                }
                if (t.clientX < window.innerWidth / 2) {
                    if (!touchInput.active) {
                        touchInput.active = true;
                        touchInput.id = t.identifier;
                        touchInput.startX = t.clientX;
                        touchInput.startY = t.clientY;
                        touchInput.x = 0;
                        touchInput.y = 0;
                        const joy = document.getElementById('joystick-zone');
                        joy.style.display = 'block';
                        joy.style.left = (t.clientX - 50) + 'px';
                        joy.style.top = (t.clientY - 50) + 'px';
                        updateJoystickVisual(0, 0);
                    }
                } else {
                    keys.Space = true;
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 2) {
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const ratio = pinchStartDist / dist;
                zoom = Math.max(0.5, Math.min(2.5, pinchStartZoom * ratio));
            }
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (touchInput.active && t.identifier === touchInput.id) {
                    const maxDist = 50; 
                    let dx = t.clientX - touchInput.startX;
                    let dy = t.clientY - touchInput.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > maxDist) {
                        const ratio = maxDist / dist;
                        dx *= ratio;
                        dy *= ratio;
                        touchInput.run = true; 
                    } else {
                        touchInput.run = false;
                    }
                    touchInput.x = dx / maxDist;
                    touchInput.y = dy / maxDist;
                    updateJoystickVisual(dx, dy);
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (touchInput.active && t.identifier === touchInput.id) {
                    touchInput.active = false;
                    touchInput.x = 0;
                    touchInput.y = 0;
                    touchInput.run = false;
                    document.getElementById('joystick-zone').style.display = 'none';
                } else {
                    keys.Space = false;
                }
            }
        }

        function updateJoystickVisual(x, y) {
            const knob = document.getElementById('joystick-knob');
            knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
        }

        function playStepSound(isRunning) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            osc.type = 'triangle'; 
            const startFreq = isRunning ? 180 : 120;
            const endFreq = 40;
            osc.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(endFreq, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function createBox(w, h, d, radius = CORNER_RADIUS) {
            return new RoundedBoxGeometry(w, h, d, 4, radius);
        }

        function createSmartY() {
            smartY = new THREE.Group();
            smartY.scale.set(BASE_SCALE, BASE_SCALE, BASE_SCALE);

            const blueMat = new THREE.MeshStandardMaterial({ color: 0x2196F3, roughness: 0.3 });
            const darkGreyMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            const torso = new THREE.Group();
            // [FIXED] Raised torso position so feet bottom is at y=0
            torso.position.y = 2.56; 
            smartY.add(torso);

            const pelvis = new THREE.Mesh(createBox(1, 0.4, 0.6), blueMat);
            pelvis.position.y = -0.57; pelvis.castShadow = true; torso.add(pelvis);

            const waist = new THREE.Mesh(createBox(0.85, 0.12, 0.45), darkGreyMat);
            waist.position.y = -0.31; waist.castShadow = true; torso.add(waist);

            const chest = new THREE.Mesh(createBox(1, 1.0, 0.6), blueMat);
            chest.position.y = 0.25; chest.castShadow = true; torso.add(chest);
            rig.chest = chest;

            const head = new THREE.Mesh(createBox(1.2, 1, 1), blueMat);
            head.position.y = 1.4; head.castShadow = true; torso.add(head);
            rig.head = head;

            const eyeGeo = new THREE.PlaneGeometry(0.25, 0.25);
            const leftEye = new THREE.Mesh(eyeGeo, whiteMat); leftEye.position.set(-0.25, 0.15, 0.51); head.add(leftEye);
            leftPupil = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), blackMat); leftPupil.position.z = 0.01; leftPupil.position.y = 0.05; leftEye.add(leftPupil);
            
            const rightEye = new THREE.Mesh(eyeGeo, whiteMat); rightEye.position.set(0.25, 0.15, 0.51); head.add(rightEye);
            rightPupil = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), blackMat); rightPupil.position.z = 0.01; rightPupil.position.y = 0.05; rightEye.add(rightPupil);

            const mouthGroup = new THREE.Group(); mouthGroup.position.set(0, -0.2, 0.51); head.add(mouthGroup);
            const mouthPixelGeo = new THREE.BoxGeometry(0.06, 0.06, 0.02);
            [[-0.16, 0.05], [-0.09, 0], [0, -0.05], [0.09, 0], [0.16, 0.05]].forEach(pos => {
                const m = new THREE.Mesh(mouthPixelGeo, blackMat); m.position.set(pos[0], pos[1], 0); mouthGroup.add(m);
            });

            const antStem = new THREE.Mesh(createBox(0.05, 0.3, 0.05), darkGreyMat); 
            antStem.position.y = 0.65; head.add(antStem);
            const antBulb = new THREE.Mesh(createBox(0.15, 0.15, 0.15), new THREE.MeshBasicMaterial({color: 0xff0000})); 
            antBulb.position.y = 0.2; antStem.add(antBulb);

            function createArticulatedLimb(isArm, rigTarget) {
                const limbAnchor = new THREE.Group();
                const width = isArm ? 0.25 : 0.3;
                const upperLen = isArm ? 0.5 : 0.7;
                const lowerLen = isArm ? 0.5 : 0.7;
                const jointSize = width * 0.8;

                const upper = new THREE.Mesh(createBox(width, upperLen, width), blueMat);
                upper.position.y = -upperLen / 2; upper.castShadow = true; limbAnchor.add(upper);

                const lowerPivot = new THREE.Group(); lowerPivot.position.y = -upperLen; limbAnchor.add(lowerPivot);
                const joint = new THREE.Mesh(createBox(jointSize, jointSize, jointSize), darkGreyMat); lowerPivot.add(joint);

                const lower = new THREE.Mesh(createBox(width, lowerLen, width), blueMat);
                lower.position.y = - (lowerLen / 2) - (jointSize / 2); lower.castShadow = true; lowerPivot.add(lower);

                if (isArm) {
                    const handGroup = new THREE.Group();
                    handGroup.position.y = -lowerLen - jointSize - 0.02;
                    lowerPivot.add(handGroup);

                    const palm = new THREE.Mesh(createBox(width * 0.9, 0.15, width * 0.9), darkGreyMat);
                    palm.castShadow = true; handGroup.add(palm);

                    const fingerGeo = createBox(0.04, 0.12, width * 0.9);
                    const finger1 = new THREE.Mesh(fingerGeo, darkGreyMat); finger1.position.set(-0.08, -0.12, 0); finger1.castShadow = true; handGroup.add(finger1);
                    const finger2 = new THREE.Mesh(fingerGeo, darkGreyMat); finger2.position.set(0.08, -0.12, 0); finger2.castShadow = true; handGroup.add(finger2);
                } else {
                    const foot = new THREE.Mesh(createBox(width * 1.1, 0.2, width * 2), darkGreyMat);
                    foot.position.y = -lowerLen - jointSize - 0.1; foot.position.z = width * 0.5; lowerPivot.add(foot);
                }
                rigTarget.upper = limbAnchor; rigTarget.lower = lowerPivot;
                return limbAnchor;
            }

            const leftArm = createArticulatedLimb(true, rig.leftArm); leftArm.position.set(-0.7, 0.6, 0); torso.add(leftArm);
            const rightArm = createArticulatedLimb(true, rig.rightArm); rightArm.position.set(0.7, 0.6, 0); torso.add(rightArm);
            const leftLeg = createArticulatedLimb(false, rig.leftLeg); leftLeg.position.set(-0.3, -0.72, 0); torso.add(leftLeg);
            const rightLeg = createArticulatedLimb(false, rig.rightLeg); rightLeg.position.set(0.3, -0.72, 0); torso.add(rightLeg);

            scene.add(smartY);
        }

        function createParrot() {
            parrot = new THREE.Group();

            const greenMat = new THREE.MeshStandardMaterial({ color: 0x4CAF50 });
            const redMat = new THREE.MeshStandardMaterial({ color: 0xF44336 });
            const yellowMat = new THREE.MeshStandardMaterial({ color: 0xFFEB3B });
            const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            parrot.userData = { 
                lWing: null, rWing: null, state: 0, targetPos: new THREE.Vector3(),
                targetObj: null, nextActionTime: 0, landingOffset: new THREE.Vector3(), 
                armPose: { z: 0, x: 0 } 
            };

            // Use rounded boxes for Parrot too
            const body = new THREE.Mesh(createBox(0.15, 0.2, 0.25, 0.04), greenMat);
            body.castShadow = true; parrot.add(body);

            // Head facing +Z
            const head = new THREE.Mesh(createBox(0.12, 0.12, 0.12, 0.03), greenMat);
            head.position.set(0, 0.15, 0.1); 
            head.castShadow = true; parrot.add(head);

            const beak = new THREE.Mesh(new THREE.ConeGeometry(0.04, 0.08, 8), yellowMat);
            beak.rotation.x = Math.PI / 2; 
            beak.position.set(0, 0, 0.08); 
            head.add(beak);

            const eyeGeo = new THREE.PlaneGeometry(0.03, 0.03);
            const leftEye = new THREE.Mesh(eyeGeo, blackMat); leftEye.position.set(-0.061, 0.02, 0.02); leftEye.rotation.y = -Math.PI / 2; head.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, blackMat); rightEye.position.set(0.061, 0.02, 0.02); rightEye.rotation.y = Math.PI / 2; head.add(rightEye);

            const wingGeo = createBox(0.25, 0.02, 0.15, 0.01);
            
            const lWingGroup = new THREE.Group(); lWingGroup.position.set(-0.08, 0.05, 0); parrot.add(lWingGroup);
            const lWing = new THREE.Mesh(wingGeo, redMat); lWing.position.x = -0.125; lWing.castShadow = true; lWingGroup.add(lWing);

            const rWingGroup = new THREE.Group(); rWingGroup.position.set(0.08, 0.05, 0); parrot.add(rWingGroup);
            const rWing = new THREE.Mesh(wingGeo, redMat); rWing.position.x = 0.125; rWing.castShadow = true; rWingGroup.add(rWing);

            // Tail facing -Z
            const tail = new THREE.Mesh(createBox(0.1, 0.02, 0.2, 0.01), redMat);
            tail.position.set(0, -0.05, -0.2); 
            tail.castShadow = true; parrot.add(tail);

            parrot.userData.lWing = lWingGroup;
            parrot.userData.rWing = rWingGroup;

            parrot.position.set(2, 3, 2);
            scene.add(parrot);
        }

        function createCity() {
            const cityGroup = new THREE.Group();
            scene.add(cityGroup);

            const matGrey = new THREE.MeshStandardMaterial({ color: 0x888888 });
            const matDarkGrey = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const matBlueGlass = new THREE.MeshStandardMaterial({ color: 0x88CCFF });
            const matSidewalk = new THREE.MeshStandardMaterial({ color: 0x999999 }); 
            const matRoadLine = new THREE.MeshBasicMaterial({ color: 0xFFFFFF }); 

            const blockSize = 30; 
            const streetWidth = 10; 
            const buildingArea = blockSize - streetWidth; 
            const sidewalkHeight = 0.2;
            
            for(let x = -150; x <= 150; x += blockSize) {
                for(let z = -150; z <= 150; z += blockSize) {
                    
                    const dist = Math.sqrt(x*x + z*z);
                    if(dist < 25) continue;

                    const swGeo = createBox(buildingArea, sidewalkHeight, buildingArea, 0.1);
                    const sidewalk = new THREE.Mesh(swGeo, matSidewalk);
                    sidewalk.position.set(x, sidewalkHeight/2, z);
                    sidewalk.receiveShadow = true;
                    cityGroup.add(sidewalk);

                    cityMap.sidewalks.push({
                        minX: x - buildingArea/2, maxX: x + buildingArea/2,
                        minZ: z - buildingArea/2, maxZ: z + buildingArea/2,
                        height: sidewalkHeight
                    });

                    if (Math.random() > 0.15) {
                        const h = 5 + Math.random() * 20; 
                        const w = buildingArea * 0.7; 
                        const d = buildingArea * 0.7; 
                        const randMat = Math.random() > 0.5 ? matGrey : (Math.random() > 0.5 ? matDarkGrey : matBlueGlass);
                        const bGeo = createBox(w, h, d, 0.2);
                        const building = new THREE.Mesh(bGeo, randMat);
                        building.position.set(x, h/2 + sidewalkHeight, z); 
                        building.castShadow = true;
                        building.receiveShadow = true;
                        cityGroup.add(building);

                        cityMap.buildings.push({
                            minX: x - w/2, maxX: x + w/2,
                            minZ: z - d/2, maxZ: z + d/2
                        });
                    }

                    const lineGeoX = new THREE.PlaneGeometry(blockSize, 0.15);
                    const lineX = new THREE.Mesh(lineGeoX, matRoadLine);
                    lineX.rotation.x = -Math.PI/2;
                    lineX.position.set(x + blockSize/2, 0.02, z); 
                    cityGroup.add(lineX);

                    const lineGeoZ = new THREE.PlaneGeometry(0.15, blockSize);
                    const lineZ = new THREE.Mesh(lineGeoZ, matRoadLine);
                    lineZ.rotation.x = -Math.PI/2;
                    lineZ.position.set(x, 0.02, z + blockSize/2);
                    cityGroup.add(lineZ);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            let holdingParrot = null; 

            if (parrot && smartY) {
                const now = Date.now();
                const pData = parrot.userData;
                const pTime = now * 0.002;

                if (pData.state === 0) {
                    if (now > pData.nextActionTime) {
                        const rand = Math.random();
                        if (rand < 0.4) {
                            pData.state = 1; 
                            const parts = ['head', 'lShoulder', 'rShoulder', 'lArm', 'rArm'];
                            pData.targetObj = parts[Math.floor(Math.random() * parts.length)];
                            if (pData.targetObj === 'head') {
                                const side = Math.random() > 0.5 ? 1 : -1;
                                pData.landingOffset.set(side * 0.35 * BASE_SCALE, 0.55 * BASE_SCALE, 0);
                            } else if (pData.targetObj.includes('Arm')) {
                                pData.armPose.z = 1.1 + Math.random() * 0.5; 
                                pData.armPose.x = 0.1 + Math.random() * 0.4;
                            }
                        } else {
                            const isExploring = Math.random() < 0.3;
                            const radius = isExploring ? 8 + Math.random() * 7 : 3 + Math.random() * 2;
                            const angle = Math.random() * Math.PI * 2;
                            const height = 4 + Math.random() * 10; 
                            pData.targetPos.set(
                                smartY.position.x + Math.sin(angle) * radius,
                                smartY.position.y + height,
                                smartY.position.z + Math.cos(angle) * radius
                            );
                            pData.nextActionTime = now + 3000 + Math.random() * 4000;
                        }
                    }

                    const dist = parrot.position.distanceTo(pData.targetPos);
                    const speed = 0.03 + (dist > 5 ? 0.05 : 0.0);
                    parrot.position.lerp(pData.targetPos, speed);
                    const lookPos = pData.targetPos.clone();
                    lookPos.y = parrot.position.y; 
                    parrot.lookAt(lookPos);

                    const flapSpeed = 15;
                    const unfoldSpeed = 0.1;
                    pData.lWing.rotation.y = THREE.MathUtils.lerp(pData.lWing.rotation.y, 0, unfoldSpeed);
                    pData.rWing.rotation.y = THREE.MathUtils.lerp(pData.rWing.rotation.y, 0, unfoldSpeed);
                    pData.lWing.rotation.z = Math.sin(pTime * flapSpeed) * 0.6;
                    pData.rWing.rotation.z = -Math.sin(pTime * flapSpeed) * 0.6;

                } else if (pData.state === 1) {
                    let targetWorldPos = new THREE.Vector3();
                    if (pData.targetObj === 'lArm') holdingParrot = 'left';
                    if (pData.targetObj === 'rArm') holdingParrot = 'right';

                    if (pData.targetObj === 'head') {
                        rig.head.getWorldPosition(targetWorldPos);
                        targetWorldPos.add(pData.landingOffset); 
                    } else if (pData.targetObj === 'lShoulder') {
                        rig.chest.getWorldPosition(targetWorldPos);
                        const offset = new THREE.Vector3(-0.6 * BASE_SCALE, 0.4 * BASE_SCALE, 0).applyQuaternion(rig.chest.getWorldQuaternion(new THREE.Quaternion()));
                        targetWorldPos.add(offset);
                    } else if (pData.targetObj === 'rShoulder') {
                        rig.chest.getWorldPosition(targetWorldPos);
                        const offset = new THREE.Vector3(0.6 * BASE_SCALE, 0.4 * BASE_SCALE, 0).applyQuaternion(rig.chest.getWorldQuaternion(new THREE.Quaternion()));
                        targetWorldPos.add(offset);
                    } else if (pData.targetObj === 'lArm') {
                        rig.leftArm.lower.getWorldPosition(targetWorldPos);
                        targetWorldPos.y += 0.2; 
                    } else if (pData.targetObj === 'rArm') {
                        rig.rightArm.lower.getWorldPosition(targetWorldPos);
                        targetWorldPos.y += 0.2;
                    }

                    const dist = parrot.position.distanceTo(targetWorldPos);
                    parrot.position.lerp(targetWorldPos, 0.08);

                    // Flare rotation to match SmartY
                    if (dist > 0.6) {
                        parrot.lookAt(targetWorldPos);
                    } else {
                        const targetQuat = new THREE.Quaternion();
                        targetQuat.setFromEuler(new THREE.Euler(0, smartY.rotation.y, 0));
                        parrot.quaternion.slerp(targetQuat, 0.15);
                    }

                    if (dist < 0.1) {
                        pData.state = 2; 
                        pData.nextActionTime = now + 2000 + Math.random() * 3000; 
                    }

                    pData.lWing.rotation.z = Math.sin(pTime * 25) * 0.5;
                    pData.rWing.rotation.z = -Math.sin(pTime * 25) * 0.5;

                } else if (pData.state === 2) {
                    let anchorPos = new THREE.Vector3();
                    if (pData.targetObj === 'lArm') holdingParrot = 'left';
                    if (pData.targetObj === 'rArm') holdingParrot = 'right';

                    if (pData.targetObj === 'head') {
                        rig.head.getWorldPosition(anchorPos);
                        anchorPos.add(pData.landingOffset); 
                    } else if (pData.targetObj === 'lShoulder') {
                        rig.chest.getWorldPosition(anchorPos);
                        const offset = new THREE.Vector3(-0.6 * BASE_SCALE, 0.4 * BASE_SCALE, 0).applyQuaternion(rig.chest.getWorldQuaternion(new THREE.Quaternion()));
                        anchorPos.add(offset);
                    } else if (pData.targetObj === 'rShoulder') {
                        rig.chest.getWorldPosition(anchorPos);
                        const offset = new THREE.Vector3(0.6 * BASE_SCALE, 0.4 * BASE_SCALE, 0).applyQuaternion(rig.chest.getWorldQuaternion(new THREE.Quaternion()));
                        anchorPos.add(offset);
                    } else if (pData.targetObj === 'lArm') {
                        rig.leftArm.lower.getWorldPosition(anchorPos);
                        anchorPos.y += 0.2; 
                    } else if (pData.targetObj === 'rArm') {
                        rig.rightArm.lower.getWorldPosition(anchorPos);
                        anchorPos.y += 0.2;
                    }

                    parrot.position.copy(anchorPos);
                    parrot.rotation.set(0, smartY.rotation.y, 0); 

                    const foldSpeed = 0.1;
                    pData.lWing.rotation.z = THREE.MathUtils.lerp(pData.lWing.rotation.z, 0, foldSpeed);
                    pData.rWing.rotation.z = THREE.MathUtils.lerp(pData.rWing.rotation.z, 0, foldSpeed);
                    pData.lWing.rotation.y = THREE.MathUtils.lerp(pData.lWing.rotation.y, -1.4, foldSpeed);
                    pData.rWing.rotation.y = THREE.MathUtils.lerp(pData.rWing.rotation.y, 1.4, foldSpeed);

                    if (now > pData.nextActionTime) {
                        pData.state = 0; 
                        pData.targetPos.set(parrot.position.x, parrot.position.y + 4, parrot.position.z); 
                        pData.nextActionTime = now + 1000;
                    }
                }
            }

            if (Date.now() > nextEyeMove) {
                if (Math.random() > 0.3) {
                    eyeTargetX = (Math.random() - 0.5) * 0.14; 
                    eyeTargetY = (Math.random() - 0.5) * 0.14;
                } else { eyeTargetX = 0; eyeTargetY = 0.05; }
                nextEyeMove = Date.now() + 1500 + Math.random() * 2500;
            }
            if (leftPupil && rightPupil) {
                const lerpSpeed = 0.1;
                leftPupil.position.x += (eyeTargetX - leftPupil.position.x) * lerpSpeed;
                leftPupil.position.y += (eyeTargetY - leftPupil.position.y) * lerpSpeed;
                rightPupil.position.x += (eyeTargetX - rightPupil.position.x) * lerpSpeed;
                rightPupil.position.y += (eyeTargetY - rightPupil.position.y) * lerpSpeed;
            }

            let moved = false;
            const moveVec = new THREE.Vector3();
            
            let inputX = 0;
            let inputZ = 0;
            let isRunning = false;

            if (keys.ArrowUp) inputZ -= 1;
            if (keys.ArrowDown) inputZ += 1;
            if (keys.ArrowLeft) inputX -= 1;
            if (keys.ArrowRight) inputX += 1;
            if (keys.Control) isRunning = true;

            if (touchInput.active) {
                inputX += touchInput.x;
                inputZ += touchInput.y;
                if (touchInput.run) isRunning = true;
            }

            const currentSpeed = isRunning ? moveSpeed * 2.2 : moveSpeed;

            // --- IMPROVED PHYSICS & COLLISION ---
            if (isGrounded && (Math.abs(inputX) > 0.1 || Math.abs(inputZ) > 0.1)) {
                
                // [NEW] Calculate Movement Vector Relative to Camera View
                const cos = Math.cos(camYaw);
                const sin = Math.sin(camYaw);
                
                // Rotate input vector by camera angle
                // Forward (inputZ < 0) should move away from camera
                const worldInputX = inputX * cos + inputZ * sin;
                const worldInputZ = -inputX * sin + inputZ * cos;

                let potentialX = smartY.position.x + (worldInputX * currentSpeed);
                let potentialZ = smartY.position.z + (worldInputZ * currentSpeed);

                const currentX = smartY.position.x;
                const currentZ = smartY.position.z;

                let nextX = currentX;
                let nextZ = currentZ;

                if (!checkBuildingCollision(potentialX, currentZ)) {
                    nextX = potentialX;
                }
                
                if (!checkBuildingCollision(nextX, potentialZ)) {
                    nextZ = potentialZ;
                }

                if (nextX !== currentX || nextZ !== currentZ) {
                    moved = true;
                    smartY.position.x = nextX;
                    smartY.position.z = nextZ;
                    
                    // Update Rotation based on world movement vector
                    const targetRotation = Math.atan2(worldInputX, worldInputZ);
                    let rotDiff = targetRotation - smartY.rotation.y;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                    while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    smartY.rotation.y += rotDiff * 0.8; 
                }
            }

            const groundHeight = getGroundHeight(smartY.position.x, smartY.position.z);

            if (keys.Space && isGrounded) {
                velocityY = jumpForce;
                isGrounded = false;
                smartY.scale.set(BASE_SCALE * 1.1, BASE_SCALE * 0.85, BASE_SCALE * 1.1);
                const forwardImpulse = currentSpeed * 0.8; 
                jumpMomentum.x = Math.sin(smartY.rotation.y) * forwardImpulse;
                jumpMomentum.z = Math.cos(smartY.rotation.y) * forwardImpulse;
            }

            if (!isGrounded) {
                velocityY -= gravity;
                smartY.position.y += velocityY;
                smartY.position.x += jumpMomentum.x;
                smartY.position.z += jumpMomentum.z;

                if (checkBuildingCollision(smartY.position.x, smartY.position.z)) {
                    smartY.position.x -= jumpMomentum.x;
                    smartY.position.z -= jumpMomentum.z;
                    jumpMomentum.set(0,0,0);
                }

                if (smartY.position.y <= groundHeight) {
                    smartY.position.y = groundHeight;
                    isGrounded = true;
                    velocityY = 0;
                    smartY.scale.set(BASE_SCALE * 1.1, BASE_SCALE * 0.85, BASE_SCALE * 1.1);
                    jumpMomentum.set(0, 0, 0);
                }
            } else {
                if (smartY.position.y > groundHeight) {
                    isGrounded = false;
                    velocityY = -0.05; 
                } else if (smartY.position.y < groundHeight) {
                    smartY.position.y = THREE.MathUtils.lerp(smartY.position.y, groundHeight, 0.5);
                }
            }

            if (isGrounded) {
                smartY.scale.lerp(new THREE.Vector3(BASE_SCALE, BASE_SCALE, BASE_SCALE), 0.15);
            } else {
                smartY.scale.lerp(new THREE.Vector3(BASE_SCALE * 0.9, BASE_SCALE * 1.1, BASE_SCALE * 0.9), 0.1);
            }

            // --- ANATOMIC ANIMATION SYSTEM ---
            if (moved) {
                animTime += isRunning ? 0.6 : 0.24; 
            } else {
                animTime += 0.05; 
            }
            
            const torso = smartY.children[0];

            if (torso) {
                if (moved && isGrounded) {
                    const leanAmount = isRunning ? 0.35 : 0.15;
                    torso.rotation.x = THREE.MathUtils.lerp(torso.rotation.x, leanAmount, 0.1); 
                } else {
                    torso.rotation.x = THREE.MathUtils.lerp(torso.rotation.x, 0, 0.1); 
                }
            }

            let lArmUpperX = 0, lArmLowerX = -0.1, lArmUpperZ = 0;
            let rArmUpperX = 0, rArmLowerX = -0.1, rArmUpperZ = 0;
            let lLegUpperX = 0, lLegLowerX = 0;
            let rLegUpperX = 0, rLegLowerX = 0;

            if (!isGrounded) {
                const targetHip = velocityY > 0 ? -1.2 : 0.0;
                const targetKnee = velocityY > 0 ? 1.5 : 0.2;
                lLegUpperX = targetHip; rLegUpperX = targetHip;
                lLegLowerX = targetKnee; rLegLowerX = targetKnee;
                lArmUpperX = -2.5; rArmUpperX = -2.5;
                lArmLowerX = 0; rArmLowerX = 0;
            } else if (moved) {
                const walkAmp = isRunning ? 1.0 : 0.8; 
                const forwardBias = isRunning ? -0.1 : -0.25;
                lLegUpperX = -Math.sin(animTime) * walkAmp + forwardBias;
                rLegUpperX = -Math.sin(animTime + Math.PI) * walkAmp + forwardBias;
                lLegLowerX = Math.max(0, Math.cos(animTime)) * (isRunning ? 1.8 : 1.2);
                rLegLowerX = Math.max(0, Math.cos(animTime + Math.PI)) * (isRunning ? 1.8 : 1.2);
                lArmUpperX = -lLegUpperX;
                rArmUpperX = -rLegUpperX;
                lArmLowerX = -0.5 - Math.sin(animTime) * 0.2;
                rArmLowerX = -0.5 - Math.sin(animTime + Math.PI) * 0.2;

                if (Math.floor(animTime / Math.PI) > Math.floor(lastAnimTime / Math.PI)) {
                    playStepSound(isRunning);
                }
            } else {
                lArmLowerX = -0.1; rArmLowerX = -0.1;
            }

            if (holdingParrot === 'left') {
                lArmUpperZ = -parrot.userData.armPose.z; 
                lArmUpperX = -parrot.userData.armPose.x; 
                lArmLowerX = -0.2; 
            } else if (holdingParrot === 'right') {
                rArmUpperZ = parrot.userData.armPose.z; 
                rArmUpperX = -parrot.userData.armPose.x; 
                rArmLowerX = -0.2; 
            }

            const lerpSpeed = 0.15;
            rig.leftLeg.upper.rotation.x = THREE.MathUtils.lerp(rig.leftLeg.upper.rotation.x, lLegUpperX, lerpSpeed);
            rig.rightLeg.upper.rotation.x = THREE.MathUtils.lerp(rig.rightLeg.upper.rotation.x, rLegUpperX, lerpSpeed);
            rig.leftLeg.lower.rotation.x = THREE.MathUtils.lerp(rig.leftLeg.lower.rotation.x, lLegLowerX, lerpSpeed);
            rig.rightLeg.lower.rotation.x = THREE.MathUtils.lerp(rig.rightLeg.lower.rotation.x, rLegLowerX, lerpSpeed);

            rig.leftArm.upper.rotation.x = THREE.MathUtils.lerp(rig.leftArm.upper.rotation.x, lArmUpperX, lerpSpeed);
            rig.rightArm.upper.rotation.x = THREE.MathUtils.lerp(rig.rightArm.upper.rotation.x, rArmUpperX, lerpSpeed);
            rig.leftArm.upper.rotation.z = THREE.MathUtils.lerp(rig.leftArm.upper.rotation.z, lArmUpperZ, lerpSpeed);
            rig.rightArm.upper.rotation.z = THREE.MathUtils.lerp(rig.rightArm.upper.rotation.z, rArmUpperZ, lerpSpeed);
            
            rig.leftArm.lower.rotation.x = THREE.MathUtils.lerp(rig.leftArm.lower.rotation.x, lArmLowerX, lerpSpeed);
            rig.rightArm.lower.rotation.x = THREE.MathUtils.lerp(rig.rightArm.lower.rotation.x, rArmLowerX, lerpSpeed);

            lastAnimTime = animTime;

            const radius = 8 * zoom;
            const offsetY = radius * Math.sin(camPitch);
            const hRadius = radius * Math.cos(camPitch);
            const offsetX = hRadius * Math.sin(camYaw);
            const offsetZ = hRadius * Math.cos(camYaw);

            const targetCamPos = new THREE.Vector3(
                smartY.position.x + offsetX,
                smartY.position.y + offsetY,
                smartY.position.z + offsetZ
            );
            
            const lookTarget = new THREE.Vector3(smartY.position.x, smartY.position.y + 1.2, smartY.position.z);

            camera.position.lerp(targetCamPos, 0.1);
            camera.lookAt(lookTarget);

            renderer.render(scene, camera);
        }

        // Init call inside module
        init();
    </script>
</body>
</html>
