<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SmartY the Robot</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #f0f0f0; 
            font-family: sans-serif;
            touch-action: none; 
            user-select: none;
            -webkit-user-select: none;
        }
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.8);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 { margin: 0 0 5px 0; font-size: 1.2rem; color: #333; }
        p { margin: 0; font-size: 0.9rem; color: #666; }
        .key {
            display: inline-block;
            background: #eee;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 0.8rem;
            font-weight: bold;
            margin: 0 2px;
        }
        .touch-hint {
            position: absolute;
            bottom: 20px;
            color: rgba(0,0,0,0.3);
            font-weight: bold;
            pointer-events: none;
            font-size: 1.2rem;
        }
        #left-hint { left: 40px; }
        #right-hint { right: 40px; }
        
        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 100px;
            height: 100px;
            border: 2px solid rgba(0,0,0,0.1);
            border-radius: 50%;
            display: none; 
            pointer-events: none;
        }
        #joystick-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 40px;
            height: 40px;
            background: rgba(33, 150, 243, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="instructions">
        <h1>Meet SmartY!</h1>
        <p><strong>Move:</strong> Arrows / Ctrl to Run / Space to Jump</p>
        <p><strong>Camera:</strong> Click & Drag to Rotate, Scroll to Zoom</p>
        <p><strong>Mobile:</strong> Left side Move, Right side Jump</p>
    </div>
    
    <div id="left-hint" class="touch-hint">Drag to Move</div>
    <div id="right-hint" class="touch-hint">Tap to Jump</div>
    
    <div id="joystick-zone"><div id="joystick-knob"></div></div>

    <!-- Load Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let scene, camera, renderer;
        let smartY; // Our character group
        let zoom = 1.0; 
        
        // Camera Orbit Variables
        let isMouseDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let camYaw = 0;     // Horizontal angle
        let camPitch = 0.5; // Vertical angle (0.5 rad is slightly looking down)

        let audioCtx;
        
        const rig = {
            leftArm: { upper: null, lower: null },
            rightArm: { upper: null, lower: null },
            leftLeg: { upper: null, lower: null },
            rightLeg: { upper: null, lower: null }
        };

        const moveSpeed = 0.08; 
        
        let animTime = 0; 
        let lastAnimTime = 0; 

        let leftPupil, rightPupil;
        let eyeTargetX = 0;
        let eyeTargetY = 0.05;
        let nextEyeMove = 0;

        let velocityY = 0;
        let isGrounded = true;
        const gravity = 0.015;
        const jumpForce = 0.45;
        let jumpMomentum = new THREE.Vector3(0, 0, 0);

        const keys = {
            ArrowUp: false,
            ArrowDown: false,
            ArrowLeft: false,
            ArrowRight: false,
            Space: false,
            Control: false
        };

        const touchInput = {
            active: false,
            x: 0, 
            y: 0, 
            run: false,
            id: null,
            startX: 0,
            startY: 0
        };
        
        let pinchStartDist = 0;
        let pinchStartZoom = 1.0;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xe0e0e0);
            scene.fog = new THREE.Fog(0xe0e0e0, 20, 100);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 2, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            document.body.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            scene.add(dirLight);

            const groundGeo = new THREE.PlaneGeometry(200, 200);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x999999, depthWrite: false });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            const gridHelper = new THREE.GridHelper(200, 50, 0x000000, 0x808080);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);

            createSmartY();

            window.addEventListener('resize', onWindowResize);
            
            // Mouse Drag Listeners for Camera Orbit
            renderer.domElement.addEventListener('mousedown', (e) => {
                isMouseDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mouseup', () => {
                isMouseDragging = false;
            });

            window.addEventListener('mousemove', (e) => {
                if (isMouseDragging) {
                    const deltaX = e.clientX - previousMousePosition.x;
                    const deltaY = e.clientY - previousMousePosition.y;
                    previousMousePosition = { x: e.clientX, y: e.clientY };

                    // Adjust angles
                    camYaw -= deltaX * 0.005; 
                    camPitch += deltaY * 0.005;

                    // Clamp pitch to avoid going underground or flipping
                    camPitch = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, camPitch));
                }
            });

            // Zoom Listeners
            window.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (e.deltaY > 0) {
                    zoom = Math.min(2.5, zoom + 0.1);
                } else {
                    zoom = Math.max(0.5, zoom - 0.1);
                }
            }, { passive: false });

            window.addEventListener('keydown', (e) => { 
                initAudio();
                if(e.code === 'Space') e.preventDefault(); 
                if(e.key === 'Control') keys.Control = true;
                if(keys.hasOwnProperty(e.code) || e.code === 'Space') keys[e.code] = true; 
                if (e.key === '+' || e.key === '=') zoom = Math.max(0.5, zoom - 0.1);
                if (e.key === '-' || e.key === '_') zoom = Math.min(2.5, zoom + 0.1);
            });
            window.addEventListener('keyup', (e) => { 
                if(e.key === 'Control') keys.Control = false;
                if(keys.hasOwnProperty(e.code) || e.code === 'Space') keys[e.code] = false; 
            });

            renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
            renderer.domElement.addEventListener('touchmove', handleTouchMove, { passive: false });
            renderer.domElement.addEventListener('touchend', handleTouchEnd, { passive: false });

            animate();
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            } else if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        function handleTouchStart(e) {
            e.preventDefault();
            initAudio();

            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                const halfWidth = window.innerWidth / 2;

                if (e.touches.length === 2) {
                    const dx = e.touches[0].pageX - e.touches[1].pageX;
                    const dy = e.touches[0].pageY - e.touches[1].pageY;
                    pinchStartDist = Math.sqrt(dx*dx + dy*dy);
                    pinchStartZoom = zoom;
                    continue;
                }

                if (t.clientX < halfWidth) {
                    if (!touchInput.active) {
                        touchInput.active = true;
                        touchInput.id = t.identifier;
                        touchInput.startX = t.clientX;
                        touchInput.startY = t.clientY;
                        touchInput.x = 0;
                        touchInput.y = 0;
                        const joy = document.getElementById('joystick-zone');
                        joy.style.display = 'block';
                        joy.style.left = (t.clientX - 50) + 'px';
                        joy.style.top = (t.clientY - 50) + 'px';
                        updateJoystickVisual(0, 0);
                    }
                } else {
                    keys.Space = true;
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            if (e.touches.length === 2) {
                const dx = e.touches[0].pageX - e.touches[1].pageX;
                const dy = e.touches[0].pageY - e.touches[1].pageY;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const ratio = pinchStartDist / dist;
                zoom = Math.max(0.5, Math.min(2.5, pinchStartZoom * ratio));
            }

            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (touchInput.active && t.identifier === touchInput.id) {
                    const maxDist = 50; 
                    let dx = t.clientX - touchInput.startX;
                    let dy = t.clientY - touchInput.startY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > maxDist) {
                        const ratio = maxDist / dist;
                        dx *= ratio;
                        dy *= ratio;
                        touchInput.run = true; 
                    } else {
                        touchInput.run = false;
                    }
                    touchInput.x = dx / maxDist;
                    touchInput.y = dy / maxDist;
                    updateJoystickVisual(dx, dy);
                }
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            for (let i = 0; i < e.changedTouches.length; i++) {
                const t = e.changedTouches[i];
                if (touchInput.active && t.identifier === touchInput.id) {
                    touchInput.active = false;
                    touchInput.x = 0;
                    touchInput.y = 0;
                    touchInput.run = false;
                    document.getElementById('joystick-zone').style.display = 'none';
                } else {
                    keys.Space = false;
                }
            }
        }

        function updateJoystickVisual(x, y) {
            const knob = document.getElementById('joystick-knob');
            knob.style.transform = `translate(calc(-50% + ${x}px), calc(-50% + ${y}px))`;
        }

        function playStepSound(isRunning) {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            osc.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            osc.type = 'triangle'; 
            const startFreq = isRunning ? 180 : 120;
            const endFreq = 40;
            osc.frequency.setValueAtTime(startFreq, audioCtx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(endFreq, audioCtx.currentTime + 0.1);
            gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.1);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        function createSmartY() {
            smartY = new THREE.Group();

            const blueMat = new THREE.MeshStandardMaterial({ color: 0x2196F3, roughness: 0.3 });
            const darkGreyMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const blackMat = new THREE.MeshBasicMaterial({ color: 0x000000 });

            // Helper to add thin black edges
            function addEdges(mesh) {
                const edges = new THREE.EdgesGeometry(mesh.geometry);
                const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000 }));
                mesh.add(line);
            }

            const torsoGeo = new THREE.BoxGeometry(1, 1.5, 0.6);
            const torso = new THREE.Mesh(torsoGeo, blueMat);
            torso.position.y = 2.4; torso.castShadow = true; 
            addEdges(torso);
            smartY.add(torso);

            const headGeo = new THREE.BoxGeometry(1.2, 1, 1); 
            const head = new THREE.Mesh(headGeo, blueMat);
            head.position.y = 1.4; head.castShadow = true; 
            addEdges(head);
            torso.add(head);

            const eyeGeo = new THREE.PlaneGeometry(0.25, 0.25);
            const leftEye = new THREE.Mesh(eyeGeo, whiteMat); leftEye.position.set(-0.25, 0.15, 0.51); head.add(leftEye);
            leftPupil = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), blackMat); leftPupil.position.z = 0.01; leftPupil.position.y = 0.05; leftEye.add(leftPupil);
            
            const rightEye = new THREE.Mesh(eyeGeo, whiteMat); rightEye.position.set(0.25, 0.15, 0.51); head.add(rightEye);
            rightPupil = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), blackMat); rightPupil.position.z = 0.01; rightPupil.position.y = 0.05; rightEye.add(rightPupil);

            const mouthGroup = new THREE.Group(); mouthGroup.position.set(0, -0.2, 0.51); head.add(mouthGroup);
            const mouthPixelGeo = new THREE.BoxGeometry(0.06, 0.06, 0.02);
            [[-0.16, 0.05], [-0.09, 0], [0, -0.05], [0.09, 0], [0.16, 0.05]].forEach(pos => {
                const m = new THREE.Mesh(mouthPixelGeo, blackMat); m.position.set(pos[0], pos[1], 0); mouthGroup.add(m);
            });

            const antStem = new THREE.Mesh(new THREE.BoxGeometry(0.05, 0.3, 0.05), darkGreyMat); antStem.position.y = 0.65; 
            addEdges(antStem);
            head.add(antStem);
            
            const antBulb = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 0.15), new THREE.MeshBasicMaterial({color: 0xff0000})); antBulb.position.y = 0.2; 
            addEdges(antBulb);
            antStem.add(antBulb);

            function createArticulatedLimb(isArm, rigTarget) {
                const limbAnchor = new THREE.Group();
                const width = isArm ? 0.25 : 0.3;
                const upperLen = isArm ? 0.5 : 0.7;
                const lowerLen = isArm ? 0.5 : 0.7;
                const jointSize = width * 0.8;

                const upper = new THREE.Mesh(new THREE.BoxGeometry(width, upperLen, width), blueMat);
                upper.position.y = -upperLen / 2; upper.castShadow = true; 
                addEdges(upper);
                limbAnchor.add(upper);

                const lowerPivot = new THREE.Group(); lowerPivot.position.y = -upperLen; limbAnchor.add(lowerPivot);
                const joint = new THREE.Mesh(new THREE.BoxGeometry(jointSize, jointSize, jointSize), darkGreyMat); 
                addEdges(joint);
                lowerPivot.add(joint);

                const lower = new THREE.Mesh(new THREE.BoxGeometry(width, lowerLen, width), blueMat);
                lower.position.y = - (lowerLen / 2) - (jointSize / 2); lower.castShadow = true; 
                addEdges(lower);
                lowerPivot.add(lower);

                if (isArm) {
                    const handGroup = new THREE.Group();
                    handGroup.position.y = -lowerLen - jointSize - 0.02;
                    lowerPivot.add(handGroup);

                    const palm = new THREE.Mesh(new THREE.BoxGeometry(width * 0.9, 0.15, width * 0.9), darkGreyMat);
                    palm.castShadow = true;
                    addEdges(palm);
                    handGroup.add(palm);

                    const fingerGeo = new THREE.BoxGeometry(0.05, 0.18, 0.05);
                    const finger1 = new THREE.Mesh(fingerGeo, darkGreyMat);
                    finger1.position.set(-0.08, -0.12, 0); 
                    finger1.rotation.z = 0.15; 
                    finger1.castShadow = true;
                    addEdges(finger1);
                    handGroup.add(finger1);

                    const finger2 = new THREE.Mesh(fingerGeo, darkGreyMat);
                    finger2.position.set(0.08, -0.12, 0); 
                    finger2.rotation.z = -0.15; 
                    finger2.castShadow = true;
                    addEdges(finger2);
                    handGroup.add(finger2);

                } else {
                    const foot = new THREE.Mesh(new THREE.BoxGeometry(width * 1.1, 0.2, width * 2), darkGreyMat);
                    foot.position.y = -lowerLen - jointSize - 0.1; foot.position.z = width * 0.5; 
                    addEdges(foot);
                    lowerPivot.add(foot);
                }
                rigTarget.upper = limbAnchor; rigTarget.lower = lowerPivot;
                return limbAnchor;
            }

            const leftArm = createArticulatedLimb(true, rig.leftArm); leftArm.position.set(-0.7, 0.6, 0); torso.add(leftArm);
            const rightArm = createArticulatedLimb(true, rig.rightArm); rightArm.position.set(0.7, 0.6, 0); torso.add(rightArm);
            const leftLeg = createArticulatedLimb(false, rig.leftLeg); leftLeg.position.set(-0.3, -0.75, 0); torso.add(leftLeg);
            const rightLeg = createArticulatedLimb(false, rig.rightLeg); rightLeg.position.set(0.3, -0.75, 0); torso.add(rightLeg);

            scene.add(smartY);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            if (Date.now() > nextEyeMove) {
                if (Math.random() > 0.3) {
                    eyeTargetX = (Math.random() - 0.5) * 0.14; 
                    eyeTargetY = (Math.random() - 0.5) * 0.14;
                } else { eyeTargetX = 0; eyeTargetY = 0.05; }
                nextEyeMove = Date.now() + 1500 + Math.random() * 2500;
            }
            if (leftPupil && rightPupil) {
                const lerpSpeed = 0.1;
                leftPupil.position.x += (eyeTargetX - leftPupil.position.x) * lerpSpeed;
                leftPupil.position.y += (eyeTargetY - leftPupil.position.y) * lerpSpeed;
                rightPupil.position.x += (eyeTargetX - rightPupil.position.x) * lerpSpeed;
                rightPupil.position.y += (eyeTargetY - rightPupil.position.y) * lerpSpeed;
            }

            let moved = false;
            const moveVec = new THREE.Vector3();
            
            let inputX = 0;
            let inputZ = 0;
            let isRunning = false;

            if (keys.ArrowUp) inputZ -= 1;
            if (keys.ArrowDown) inputZ += 1;
            if (keys.ArrowLeft) inputX -= 1;
            if (keys.ArrowRight) inputX += 1;
            if (keys.Control) isRunning = true;

            if (touchInput.active) {
                inputX += touchInput.x;
                inputZ += touchInput.y;
                if (touchInput.run) isRunning = true;
            }

            const currentSpeed = isRunning ? moveSpeed * 2.2 : moveSpeed;

            if (isGrounded && (Math.abs(inputX) > 0.1 || Math.abs(inputZ) > 0.1)) {
                moved = true;
                moveVec.z = inputZ * currentSpeed;
                moveVec.x = inputX * currentSpeed;
            }

            if (moved && isGrounded) {
                smartY.position.x += moveVec.x;
                smartY.position.z += moveVec.z;
                
                const targetRotation = Math.atan2(moveVec.x, moveVec.z);
                let rotDiff = targetRotation - smartY.rotation.y;
                while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
                while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                smartY.rotation.y += rotDiff * 0.8; 
            }

            if (keys.Space && isGrounded) {
                velocityY = jumpForce;
                isGrounded = false;
                smartY.scale.set(1.1, 0.85, 1.1);
                const forwardImpulse = currentSpeed * 0.8; 
                jumpMomentum.x = Math.sin(smartY.rotation.y) * forwardImpulse;
                jumpMomentum.z = Math.cos(smartY.rotation.y) * forwardImpulse;
            }

            if (velocityY > 0 && !keys.Space) velocityY -= gravity * 2.5;
            else velocityY -= gravity;

            smartY.position.y += velocityY;
            if (!isGrounded) {
                smartY.position.x += jumpMomentum.x;
                smartY.position.z += jumpMomentum.z;
            }

            if (smartY.position.y <= 0) {
                smartY.position.y = 0;
                if (!isGrounded) {
                    smartY.scale.set(1.1, 0.85, 1.1); 
                    jumpMomentum.set(0, 0, 0);
                }
                velocityY = 0;
                isGrounded = true;
                smartY.scale.lerp(new THREE.Vector3(1, 1, 1), 0.15);
            } else {
                smartY.scale.lerp(new THREE.Vector3(0.9, 1.1, 0.9), 0.1);
            }

            // --- ANATOMIC ANIMATION SYSTEM ---
            if (moved) {
                animTime += isRunning ? 0.6 : 0.24; 
            } else {
                animTime += 0.05; 
            }
            
            const torso = smartY.children[0];

            if (torso) {
                if (moved && isGrounded) {
                    const leanAmount = isRunning ? 0.35 : 0.15;
                    torso.rotation.x = THREE.MathUtils.lerp(torso.rotation.x, leanAmount, 0.1); 
                } else {
                    torso.rotation.x = THREE.MathUtils.lerp(torso.rotation.x, 0, 0.1); 
                }
            }

            if (!isGrounded) {
                const isRising = velocityY > 0;
                const targetHip = isRising ? -1.2 : 0.0;
                const targetKnee = isRising ? 1.5 : 0.2;

                rig.leftLeg.upper.rotation.x = THREE.MathUtils.lerp(rig.leftLeg.upper.rotation.x, targetHip, 0.15);
                rig.rightLeg.upper.rotation.x = THREE.MathUtils.lerp(rig.rightLeg.upper.rotation.x, targetHip, 0.15);
                rig.leftLeg.lower.rotation.x = THREE.MathUtils.lerp(rig.leftLeg.lower.rotation.x, targetKnee, 0.15);
                rig.rightLeg.lower.rotation.x = THREE.MathUtils.lerp(rig.rightLeg.lower.rotation.x, targetKnee, 0.15);

                const targetArm = -2.5; 
                rig.leftArm.upper.rotation.x = THREE.MathUtils.lerp(rig.leftArm.upper.rotation.x, targetArm, 0.1);
                rig.rightArm.upper.rotation.x = THREE.MathUtils.lerp(rig.rightArm.upper.rotation.x, targetArm, 0.1);
                rig.leftArm.lower.rotation.x = 0; 
                rig.rightArm.lower.rotation.x = 0;

            } else if (moved) {
                const walkAmp = isRunning ? 1.0 : 0.8; 
                const forwardBias = isRunning ? -0.1 : -0.25;

                const leftHipAngle = -Math.sin(animTime) * walkAmp + forwardBias;
                const rightHipAngle = -Math.sin(animTime + Math.PI) * walkAmp + forwardBias;

                rig.leftLeg.upper.rotation.x = leftHipAngle;
                rig.rightLeg.upper.rotation.x = rightHipAngle;

                const kneeBendAmp = isRunning ? 1.8 : 1.2; 
                rig.leftLeg.lower.rotation.x = Math.max(0, Math.cos(animTime)) * kneeBendAmp; 
                rig.rightLeg.lower.rotation.x = Math.max(0, Math.cos(animTime + Math.PI)) * kneeBendAmp;

                rig.leftArm.upper.rotation.x = -leftHipAngle;
                rig.rightArm.upper.rotation.x = -rightHipAngle;
                
                rig.leftArm.lower.rotation.x = -0.5 - Math.sin(animTime) * 0.2;
                rig.rightArm.lower.rotation.x = -0.5 - Math.sin(animTime + Math.PI) * 0.2;

                if (Math.floor(animTime / Math.PI) > Math.floor(lastAnimTime / Math.PI)) {
                    playStepSound(isRunning);
                }

            } else {
                const resetSpeed = 0.1;
                rig.leftLeg.upper.rotation.x = THREE.MathUtils.lerp(rig.leftLeg.upper.rotation.x, 0, resetSpeed);
                rig.rightLeg.upper.rotation.x = THREE.MathUtils.lerp(rig.rightLeg.upper.rotation.x, 0, resetSpeed);
                rig.leftLeg.lower.rotation.x = THREE.MathUtils.lerp(rig.leftLeg.lower.rotation.x, 0, resetSpeed);
                rig.rightLeg.lower.rotation.x = THREE.MathUtils.lerp(rig.rightLeg.lower.rotation.x, 0, resetSpeed);
                rig.leftArm.upper.rotation.x = THREE.MathUtils.lerp(rig.leftArm.upper.rotation.x, 0, resetSpeed);
                rig.rightArm.upper.rotation.x = THREE.MathUtils.lerp(rig.rightArm.upper.rotation.x, 0, resetSpeed);
                rig.leftArm.lower.rotation.x = THREE.MathUtils.lerp(rig.leftArm.lower.rotation.x, -0.1, resetSpeed); 
                rig.rightArm.lower.rotation.x = THREE.MathUtils.lerp(rig.rightArm.lower.rotation.x, -0.1, resetSpeed);
            }
            lastAnimTime = animTime;

            // Camera Orbit Logic
            const radius = 10 * zoom;
            const offsetY = radius * Math.sin(camPitch);
            const hRadius = radius * Math.cos(camPitch);
            const offsetX = hRadius * Math.sin(camYaw);
            const offsetZ = hRadius * Math.cos(camYaw);

            const targetCamPos = new THREE.Vector3(
                smartY.position.x + offsetX,
                smartY.position.y + offsetY,
                smartY.position.z + offsetZ
            );
            
            const lookTarget = new THREE.Vector3(smartY.position.x, smartY.position.y + 1.5, smartY.position.z);

            camera.position.lerp(targetCamPos, 0.1);
            camera.lookAt(lookTarget);

            renderer.render(scene, camera);
        }

        window.onload = init;
    </script>
</body>
</html>
